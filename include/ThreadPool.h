#pragma once

#include <iostream>
#include <vector>
#include <functional>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>
#include <atomic>

/***************************************************************************************************************************************************
    Преимущества использования пула потоков:
1. Ограничение количества одновременно выполняемых потоков, что предотвращает перегрузку системы.
2. Уменьшение накладных расходов на создание и уничтожение потоков, так как потоки создаются один раз при запуске программы.
3. Эффективное использование процессорных ядер, так как пул потоков можно настроить на использование оптимального количества потоков.

Использование пула потоков позволяет лучше контролировать использование ресурсов и избежать потенциальных проблем, 
связанных с созданием большого количества потоков. 
В нашем случае, когда количество файлов неизвестно заранее, пул потоков будет распределять задачи индексации файлов по ограниченному числу потоков, 
обеспечивая эффективную обработку файлов без перегрузки процессора.
****************************************************************************************************************************************************/

// Класс для управления пулом потоков
class ThreadPool {
    std::vector<std::thread> workers;  // Вектор потоков, которые будут выполнять задачи
    std::queue<std::function<void()>> tasks;  // Очередь задач, которые нужно выполнить

    std::mutex queueMutex;  // Мьютекс для синхронизации доступа к очереди задач
    std::condition_variable condition;  // Условная переменная для управления потоками

    bool stop;  // Флаг завершения работы пула потоков

    // Метод, выполняющийся в каждом потоке. Потоки постоянно проверяют, есть ли новые задачи в очереди, и выполняют их, когда они появляются.
    void workerThread(); 

    std::atomic<size_t> activeTasks; // Счетчик активных задач, использует атомарный тип для безопасной работы в многопоточной среде

public:
    // Конструктор, создающий фиксированное количество потоков (workers), которые постоянно работают в фоне и ждут задач из очереди.
    // numThreads - количество потоков в пуле
    ThreadPool(size_t numThreads); 

    // Деструктор. Завершает работу всех потоков в пуле
    ~ThreadPool();

    // Метод для добавления задач в очередь
    // task - задача, которую нужно выполнить
    void enqueueTask(std::function<void()> task);  

    // Метод для ожидания завершения всех задач
    // Этот метод блокирует выполнение до тех пор, пока не будут выполнены все задачи, добавленные в очередь
    void waitAllTasks();  
};
